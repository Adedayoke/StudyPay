import { addTransaction, updateTransaction, getTransactionsForAddress } from '@/lib/utils/transactionStorage'
import { Transaction } from '@/lib/types/payment'
import BigNumber from 'bignumber.js'

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
}

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
})

describe('Transaction Storage', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    localStorageMock.getItem.mockReturnValue(null)
  })

  describe('addTransaction', () => {
    it('should add a new transaction to storage', () => {
      const transaction: Transaction = {
        id: 'test-tx-1',
        amount: new BigNumber(1.5),
        fromAddress: 'sender-address',
        toAddress: 'recipient-address',
        status: 'pending',
        timestamp: Date.now(),
        signature: 'test-signature',
        purpose: 'Test payment',
        type: 'outgoing',
        category: 'food'
      }

      addTransaction(transaction)

      expect(localStorageMock.setItem).toHaveBeenCalled()
      const setItemCall = localStorageMock.setItem.mock.calls[0]
      expect(setItemCall[0]).toBe('studypay_transactions')
      
      const storedData = JSON.parse(setItemCall[1])
      expect(storedData).toHaveLength(1)
      expect(storedData[0].id).toBe('test-tx-1')
    })

    it('should append to existing transactions', () => {
      // Mock existing transactions
      const existingTransactions = [{
        id: 'existing-tx',
        amount: '0.5',
        status: 'confirmed'
      }]
      
      localStorageMock.getItem.mockReturnValue(JSON.stringify(existingTransactions))

      const newTransaction: Transaction = {
        id: 'new-tx',
        amount: new BigNumber(2.0),
        fromAddress: 'sender',
        toAddress: 'recipient',
        status: 'pending',
        timestamp: Date.now(),
        signature: 'sig',
        purpose: 'New payment',
        type: 'outgoing',
        category: 'transport'
      }

      addTransaction(newTransaction)

      const setItemCall = localStorageMock.setItem.mock.calls[0]
      const storedData = JSON.parse(setItemCall[1])
      expect(storedData).toHaveLength(2)
    })
  })

  describe('updateTransaction', () => {
    it('should update existing transaction status', () => {
      const existingTransactions = [{
        id: 'update-tx',
        amount: '1.0',
        status: 'pending',
        signature: null
      }]
      
      localStorageMock.getItem.mockReturnValue(JSON.stringify(existingTransactions))

      updateTransaction('update-tx', {
        status: 'confirmed',
        signature: 'confirmed-signature'
      })

      const setItemCall = localStorageMock.setItem.mock.calls[0]
      const storedData = JSON.parse(setItemCall[1])
      
      expect(storedData[0].status).toBe('confirmed')
      expect(storedData[0].signature).toBe('confirmed-signature')
    })

    it('should handle non-existent transaction gracefully', () => {
      localStorageMock.getItem.mockReturnValue('[]')

      expect(() => {
        updateTransaction('non-existent', { status: 'confirmed' })
      }).not.toThrow()
    })
  })

  describe('getTransactionsForAddress', () => {
    it('should filter transactions by address', () => {
      const transactions = [
        { id: 'tx1', fromAddress: 'address1', toAddress: 'address2' },
        { id: 'tx2', fromAddress: 'address2', toAddress: 'address3' },
        { id: 'tx3', fromAddress: 'address3', toAddress: 'address1' }
      ]
      
      localStorageMock.getItem.mockReturnValue(JSON.stringify(transactions))

      const result = getTransactionsForAddress('address1')

      expect(result).toHaveLength(2) // tx1 (from) and tx3 (to)
      expect(result.map(tx => tx.id)).toEqual(['tx1', 'tx3'])
    })

    it('should return empty array for unknown address', () => {
      localStorageMock.getItem.mockReturnValue('[]')

      const result = getTransactionsForAddress('unknown-address')

      expect(result).toHaveLength(0)
    })
  })
})
